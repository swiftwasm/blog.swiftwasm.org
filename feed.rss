<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>SwiftWasm Blog</title><description></description><link>https://blog.swiftwasm.org</link><language>en</language><lastBuildDate>Mon, 2 May 2022 16:09:19 +0000</lastBuildDate><pubDate>Mon, 2 May 2022 16:09:19 +0000</pubDate><ttl>250</ttl><atom:link href="https://blog.swiftwasm.org/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://blog.swiftwasm.org/posts/5-6-released</guid><title>SwiftWasm 5.6.0 is now available</title><description>SwiftWasm 5.6.0 has been released.</description><link>https://blog.swiftwasm.org/posts/5-6-released</link><pubDate>Mon, 2 May 2022 10:10:00 +0000</pubDate><content:encoded><![CDATA[<h1>SwiftWasm 5.6.0 is now available</h1><p>We're happy to announce the new release of SwiftWasm tracking upstream Swift 5.6!</p><p>Notable WebAssembly-specific changes in this release:</p><ul><li>The toolchain is now available for Ubuntu 20.04 on <code>aarch64</code> and Amazon Linux 2 on <code>x86_64</code> architectures.</li><li>Updated WASI SDK with support for <a href="https://github.com/WebAssembly/WASI/issues/13">"reactor" and "command" execution models</a>. You should be using "reactor" model for event-based (browser) applications, while "command" mode is suitable for command-line applications.</li></ul><p>With 5.6 release, when building SwiftWasm apps manually with <code>swift build</code>, you should pass <code>-Xswiftc -Xclang-linker -Xswiftc -mexec-model=reactor</code> flags to enable the "reactor" mode. When building with <code>carton</code>, "reactor" model is enabled automatically.</p><p>As for changes in upstream Swift 5.6, we recommend referring <a href="https://github.com/apple/swift/blob/release/5.6/CHANGELOG.md#swift-56">to the official changelog</a>. For convenience, here are some of the Swift Evolution proposals included in the release:</p><ul><li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0290-negative-availability.md">SE-0290</a> - Unavailability Condition</li><li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0305-swiftpm-binary-target-improvements.md">SE-0305</a> - Package Manager Binary Target Improvements</li><li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0315-placeholder-types.md">SE-0315</a> - Type placeholders (formerly, “Placeholder types”)</li><li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0320-codingkeyrepresentable.md">SE-0320</a> - Allow coding of non <code>String</code>/<code>Int</code> keyed <code>Dictionary</code> into a <code>KeyedContainer</code></li><li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0322-temporary-buffers.md">SE-0322</a> - Temporary uninitialized buffers</li><li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0324-c-lang-pointer-arg-conversion.md">SE-0324</a> - Relax diagnostics for pointer arguments to C functions</li><li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0325-swiftpm-additional-plugin-apis.md">SE-0325</a> - Additional Package Plugin APIs</li><li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0331-remove-sendable-from-unsafepointer.md">SE-0331</a> - Remove <code>Sendable</code> conformance from unsafe pointer types</li><li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0332-swiftpm-command-plugins.md">SE-0332</a> - Package Manager Command Plugins</li><li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0335-existential-any.md">SE-0335</a> - Introduces existential <code>any</code></li><li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0337-support-incremental-migration-to-concurrency-checking.md">SE-0337</a> - Incremental migration to concurrency checking</li></ul><h2>New JavaScriptKit runtime</h2><p><a href="https://github.com/swiftwasm/JavaScriptKit">JavaScriptKit</a> 0.14 is a breaking release that enables full support for SwiftWasm 5.6 and lays groundwork for <a href="https://github.com/swiftwasm/DOMKit/pull/10">future updates</a> to <a href="https://github.com/swiftwasm/DOMKit/">DOMKit</a>.</p><p>Specifically, the <code>ConvertibleToJSValue</code> conformance on <code>Array</code> and <code>Dictionary</code> has been swapped from the equality <code>== ConvertibleToJSValue</code> clause to the inheritance <code>: ConvertibleToJSValue</code> clause.</p><ul><li>This means that e.g. <code>[String]</code> is now <code>ConvertibleToJSValue</code>, but <code>[ConvertibleToJSValue]</code> no longer conforms.</li><li>the <code>jsValue()</code> method still works in both cases.</li><li>to adapt existing code, use one of these approaches:<ul><li>use generics where possible (for single-type arrays)</li><li>call <code>.map { $0.jsValue() }</code> (or <code>mapValues</code>) to get an array/dictionary of <code>JSValue</code> which you can then use as <code>ConvertibleToJSValue</code></li><li>add <code>.jsValue</code> to the end of all values in an array/dictionary literal.</li></ul></li></ul><h2>carton</h2><p>The 0.14 release of <a href="https://carton.dev"><code>carton</code></a> uses SwiftWasm 5.6.0 as the default toolchain. Additionally, issue with rebuilding projects when watching for file changes with <code>carton dev</code> has been fixed. Also, please refer to <a href="https://github.com/swiftwasm/carton/releases/tag/0.13.0">release details for <code>carton</code> 0.13.0</a> for more information on new recently introduced <code>--debug-info</code> and <code>-Xswiftc</code> command-line flags.</p><h2>Tokamak</h2><p><a href="https://tokamak.dev">Tokamak</a> 0.10.0 adds support for SwiftWasm 5.6. It also updates JavaScriptKit and OpenCombineJS dependencies. Due to issues with support for older SwiftWasm releases in the carton/SwiftPM integration, Tokamak now requires SwiftWasm 5.6 or later, while SwiftWasm 5.4 and 5.5 are no longer supported.</p><h2>OpenCollective Budget</h2><p>As may already know, <a href="https://opencollective.com/swiftwasm">our OpenCollective page</a> is the main way to financially support us. We're committed to publishing transparent and open finances, so we are excited to announce that all expenses and transactions can be viewed publicly on our <a href="https://opencollective.com/swiftwasm/transactions">OpenCollective Transactions</a> page.</p><p>So far we've spent money on monthly CI bills that cover new <code>aarch64</code> CPU architecture and Linux distributions, domain registration, email hosting, and development hardware for our maintainers.</p><h2>Acknowledgements</h2><p>We'd like to thank <a href="https://github.com/sponsors/swiftwasm">our GitHub sponsors</a> and <a href="https://opencollective.com/swiftwasm">OpenCollective contributors</a> for their support, which allowed us to continue working on SwiftWasm and related projects.</p><p>Many thanks to <a href="https://www.macstadium.com">MacStadium</a> for giving us access to Apple Silicon hardware. Without their help it would be close to impossible to set up CI for enabling full M1 support in our toolchain.</p><p>Additionally, we'd like to thank everyone who contributed their work and helped us make this release happen. These new releases wouldn't be possible without the hard work of (in alphabetical order):</p><ul><li><a href="https://github.com/andrewbarba">@andrewbarba</a></li><li><a href="https://github.com/carson-katri">@carson-katri</a></li><li><a href="https://github.com/ezraberch">@ezraberch</a></li><li><a href="https://github.com/fjtrujy">@fjtrujy</a></li><li><a href="https://github.com/j-f1">@j-f1</a></li><li><a href="https://github.com/kateinoigakukun">@kateinoigakukun</a></li><li><a href="https://github.com/MaxDesiatov">@MaxDesiatov</a></li><li><a href="https://github.com/pedrovgs">@pedrovgs</a></li><li><a href="https://github.com/SDGGiesbrecht">@SDGGiesbrecht</a></li><li><a href="https://github.com/SwiftCoderJoe">@SwiftCoderJoe</a></li><li><a href="https://github.com/yonihemi/">@yonihemi</a></li></ul><p>...and to all of our users, and everyone working on the Swift project and libraries we depend on!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftwasm.org/posts/5-5-released</guid><title>SwiftWasm 5.5.0 is now available</title><description>SwiftWasm 5.5.0 with support for async/await and Apple Silicon has been released.</description><link>https://blog.swiftwasm.org/posts/5-5-released</link><pubDate>Mon, 29 Nov 2021 10:10:00 +0000</pubDate><content:encoded><![CDATA[<h1>SwiftWasm 5.5.0 is now available</h1><p>We're happy to announce the new release of SwiftWasm tracking upstream Swift 5.5! Notably, in this release we've added support for <code>async</code>/<code>await</code>. This new feature of Swift can be integrated with JavaScript promises when you're using a new version of <a href="https://github.com/swiftwasm/JavaScriptKit">JavaScriptKit</a> that was recently tagged. See the corresponding section below for more details.</p><p>Since multi-threading in WebAssembly is still not supported across all browsers (<a href="https://webassembly.org/roadmap/">Safari is the only one lagging behind</a>), this release of SwiftWasm doesn't include the Dispatch library and ships with a single-threaded cooperative executor. This means that <code>actor</code> declarations in your code will behave as plain reference types and will all be scheduled on the main thread. If you need true parallel computation, you’ll have to write custom code against the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Web Workers API</a> (either via JavaScriptKit or delegating to raw JavaScript) to synchronize multiple SwiftWasm runtimes.</p><p>Additionally, 5.5.0 is the first release of SwiftWasm that supports Apple Silicon natively. The latest version of <a href="https://github.com/swiftwasm/carton"><code>carton</code></a> (0.12.0) will download the <code>arm64</code> distribution on Apple Silicon devices.</p><h2>New JavaScriptKit runtime</h2><p>The 0.11 release of <a href="https://github.com/swiftwasm/JavaScriptKit">JavaScriptKit</a> adds support for <code>async</code>/<code>await</code> and <code>JSPromise</code> integration. Now instances of this class have an effectful <code>async</code> property <code>value</code>. Here's example code that shows you how can <code>fetch</code> browser API be used without callbacks:</p><pre><code><span class="splash-keyword">import</span> JavaScriptKit
<span class="splash-keyword">import</span> JavaScriptEventLoop

<span class="splash-comment">// This line is required for `JSPromise.value` to work.</span>
<span class="splash-type">JavaScriptEventLoop</span>.<span class="splash-call">installGlobalExecutor</span>()

<span class="splash-keyword">private let</span> jsFetch = <span class="splash-type">JSObject</span>.<span class="splash-property">global</span>.<span class="splash-property">fetch</span>.<span class="splash-property">function</span>!
<span class="splash-keyword">func</span> fetch(<span class="splash-keyword">_</span> url: <span class="splash-type">String</span>) -&gt; <span class="splash-type">JSPromise</span> {
    <span class="splash-type">JSPromise</span>(<span class="splash-call">jsFetch</span>(url).<span class="splash-property">object</span>!)!
}

<span class="splash-keyword">struct</span> Response: <span class="splash-type">Decodable</span> {
    <span class="splash-keyword">let</span> uuid: <span class="splash-type">String</span>
}

<span class="splash-keyword">let</span> alert = <span class="splash-type">JSObject</span>.<span class="splash-property">global</span>.<span class="splash-property">alert</span>.<span class="splash-property">function</span>!
<span class="splash-keyword">let</span> document = <span class="splash-type">JSObject</span>.<span class="splash-property">global</span>.<span class="splash-property">document</span>

<span class="splash-keyword">var</span> asyncButtonElement = document.<span class="splash-call">createElement</span>(<span class="splash-string">"button"</span>)
asyncButtonElement.<span class="splash-property">innerText</span> = <span class="splash-string">"Fetch UUID demo"</span>
asyncButtonElement.<span class="splash-property">onclick</span> = .<span class="splash-call">object</span>(<span class="splash-type">JSClosure</span> { <span class="splash-keyword">_ in</span>
    <span class="splash-type">Task</span> {
        <span class="splash-keyword">do</span> {
            <span class="splash-keyword">let</span> response = <span class="splash-keyword">try await</span> <span class="splash-call">fetch</span>(<span class="splash-string">"https://httpbin.org/uuid"</span>).<span class="splash-property">value</span>
            <span class="splash-keyword">let</span> json = <span class="splash-keyword">try await</span> <span class="splash-type">JSPromise</span>(response.<span class="splash-call">json</span>().<span class="splash-property">object</span>!)!.value
            <span class="splash-keyword">let</span> parsedResponse = <span class="splash-keyword">try</span> <span class="splash-type">JSValueDecoder</span>().<span class="splash-call">decode</span>(<span class="splash-type">Response</span>.<span class="splash-keyword">self</span>, from: json)
            <span class="splash-call">alert</span>(parsedResponse.<span class="splash-property">uuid</span>)
        } <span class="splash-keyword">catch</span> {
            <span class="splash-call">print</span>(error)
        }
    }

    <span class="splash-keyword">return</span> .<span class="splash-dotAccess">undefined</span>
})

<span class="splash-keyword">_</span> = document.<span class="splash-property">body</span>.<span class="splash-call">appendChild</span>(asyncButtonElement)
</code></pre><p>Also, in this version of JavaScriptKit we're simplifying the <code>JSClosure</code> API. You no longer need to release instances of this class manually, as they will be automatically garbage-collected by the browser after neither your Swift code nor the JavaScript runtime hold any references to them. This is achieved with the new</p><p><code>FinalizationRegistry</code> Web API, for which we had to significantly increase minimum browser versions required for JavaScriptKit to work. See <a href="https://github.com/swiftwasm/JavaScriptKit#readme"><code>README.md</code></a> in the project repository for more details.</p><p>We have to mention that there's still a possibility of reference cycles with this new API. <code>FinalizationRegistry</code> doesn't implement full GC for JS closures, but it only solves dangling closure issue. For example, in this code</p><pre><code><span class="splash-keyword">var</span> button = document.<span class="splash-call">createElement</span>(<span class="splash-string">"button"</span>)
button.<span class="splash-property">onclick</span> = .<span class="splash-call">object</span>(<span class="splash-type">JSClosure</span> { [button] <span class="splash-keyword">in</span>
  <span class="splash-comment">// this capture makes a reference cycle</span>
  <span class="splash-call">print</span>(button)
})
</code></pre><p>a reference cycle is created</p><pre><code>┌─&gt; <span class="splash-type">JSObject</span> (button <span class="splash-keyword">in</span> <span class="splash-type">Swift</span>) -&gt; <span class="splash-type">HTMLElement</span> (button <span class="splash-keyword">in</span> <span class="splash-type">JS</span>) ────┐
└── <span class="splash-type">JSClosure</span> (onclick <span class="splash-keyword">in</span> <span class="splash-type">Swift</span>) &lt;─&gt; <span class="splash-type">Closure</span> (onclick <span class="splash-keyword">in</span> <span class="splash-type">JS</span>) &lt;───┘
</code></pre><p>In this case, when <code>button</code> element is removed from the main DOM tree, it cannot be deallocated. The <code>onclick</code> closure is still referenced by the button itself. These reference cycles can be resolved with the usual <code>weak</code> captures you're probably used to writing in your AppKit and UIKit code.</p><h2>Tokamak</h2><p>Based on the improvements to JavaScriptKit and major work by our contributors, we're also tagging a new 0.9.0 release of <a href="https://github.com/TokamakUI/Tokamak">Tokamak</a>, a SwiftUI-compatible framework for building browser apps with WebAssembly. We've added:</p><ul><li><code>Canvas</code> and <code>TimelineView</code> types;</li><li><code>onHover</code> modifier;</li><li><code>task</code> modifier for running <code>async</code> functions;</li><li>Sanitizers for the <code>Text</code> view.</li></ul><p>Tokamak v0.9.0 now requires Swift 5.4 or newer. Swift 5.5 (with SwiftWasm 5.5 when targeting the browser environment) is recommended.</p><h2>Acknowledgements</h2><p>We'd like to thank <a href="https://github.com/sponsors/swiftwasm">our sponsors</a> for their support, which allowed us to continue working on the SwiftWasm toolchain and related projects.</p><p>Many thanks to <a href="https://www.macstadium.com">MacStadium</a> for giving us access to Apple Silicon hardware. Without their help it would be close to impossible to set up CI for enabling full M1 support in our toolchain.</p><p>Additionally, we'd like to thank everyone who contributed their work and helped us make this release happen. These new releases wouldn't be possible without the hard work of (in alphabetical order):</p><ul><li><a href="https://github.com/agg23">@agg23</a></li><li><a href="https://github.com/carson-katri">@carson-katri</a></li><li><a href="https://github.com/ezraberch">@ezraberch</a></li><li><a href="https://github.com/Feuermurmel">@Feuermurmel</a></li><li><a href="https://github.com/kateinoigakukun">@kateinoigakukun</a></li><li><a href="https://github.com/MaxDesiatov">@MaxDesiatov</a></li><li><a href="https://github.com/mbrandonw">@mbrandonw</a></li><li><a href="https://github.com/PatrickPijnappel">@PatrickPijnappel</a></li><li><a href="https://github.com/yonihemi/">@yonihemi</a></li><li>all of our users, and everyone working on the Swift project and libraries we depend on!</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftwasm.org/posts/update-05-december-2020</guid><title>What's new in SwiftWasm #5</title><description>An update on what happened in the SwiftWasm ecosystem during December 2020.</description><link>https://blog.swiftwasm.org/posts/update-05-december-2020</link><pubDate>Mon, 11 Jan 2021 14:34:00 +0000</pubDate><content:encoded><![CDATA[<h1>What's new in SwiftWasm #5</h1><p>Happy New Year everyone! Here's a digest of what happened with <a href="https://swiftwasm.org">SwiftWasm</a> in December of 2020, published with a slight delay (it's 2021 already after all 😅).</p><h2>SwiftWasm community</h2><p>One thing we forgot to mention in our November update is that the SwiftWasm community now has <a href="https://discord.gg/ashJW8T8yp">its own Discord server</a>. In case you prefer Slack to Discord, we recommend you to join the <code>#webassembly</code> channel in <a href="https://swift-package-manager.herokuapp.com/">the SwiftPM Slack workspace</a>.</p><p>In December we saw a lot of projects built with SwiftWasm shared by the community. Here a few most noteworthy:</p><ul><li><a href="https://github.com/nerdsupremacist/memes">An online Multi-Player Meme Party Game written in Swift</a>, using <a href="https://vapor.codes/">Vapor</a> for backend and SwiftWasm with <a href="https://tokamak.dev">Tokamak</a> for frontend, built by <a href="https://github.com/nerdsupremacist">Mathias Quintero</a>.</li><li><a href="https://garrepi.dev/tic-tac-toe/">Tic-tac-toe game</a> <a href="https://github.com/johngarrett/tic-tac-toe">built with SwiftWasm</a> by <a href="https://github.com/johngarrett">John Garrett</a>.</li><li><a href="https://expressflow.com/blog/posts/webassembly-example-with-react-and-swiftwasm">WebAssembly example with React and SwiftWasm</a> by <a href="https://github.com/martinvasko">Martin Vasko</a>.</li></ul><h2>Good first issues</h2><p>Ever wanted to contribute to SwiftWasm projects, but unsure where to start? Here's a list of issues that could be suitable for beginners:</p><ul><li><a href="https://github.com/swiftwasm/swift/issues/29">swiftwasm/swift#29</a>: Fix compile error on test cases depending on platform</li><li><a href="https://github.com/swiftwasm/carton/issues/203">swiftwasm/carton#203</a>: Allow launching a specific browser with <code>carton test</code></li><li><a href="https://github.com/swiftwasm/carton/issues/201">swiftwasm/carton#201</a>: Correctly handle failure to launch browser process while testing</li><li><a href="https://github.com/swiftwasm/carton/issues/199">swiftwasm/carton#199</a>: <code>--enable-test-discovery</code> is now deprecated</li><li><a href="https://github.com/swiftwasm/carton/issues/193">swiftwasm/carton#193</a>: Add <code>--host</code> option to <code>carton dev</code> and <code>carton test</code></li><li><a href="https://github.com/TokamakUI/Tokamak/issues/350">TokamakUI/Tokamak</a>: Set up code coverage reports on GitHub Actions</li></ul><h2>Documentation</h2><h3>SwiftWasm book</h3><p>We're working on tracking down all the possible edge cases when porting code from other platforms in <a href="https://book.swiftwasm.org/">the SwiftWasm book</a>. Previously we were asked how to port code that depends on the <code>Darwin</code> module on Apple platforms or <code>Glibc</code> on Linux. We recommend using the <code>WASILibc</code> module, which obviously somewhat differs from libc on other platforms. We've added <a href="https://book.swiftwasm.org/getting-started/libc.html">a corresponding note clarifying this</a> to the book.</p><h2>Toolchain</h2><p>As the Swift team already announced <a href="https://forums.swift.org/t/swift-5-4-release-process/41936">the release process for the 5.4 version</a>, we started preparing our corresponding SwiftWasm 5.4 release. The <a href="https://github.com/swiftwasm/swift/tree/swiftwasm-release/5.4"><code>swiftwasm-release/5.4</code></a> branch in our fork now <a href="https://github.com/swiftwasm/swift/pull/2380">tracks the upstream <code>release/5.4</code> branch</a>, as we plan to tag our own 5.4.0 later this year.</p><p>Additionally, we made sure that the fork of our toolchain <a href="https://github.com/swiftwasm/swift/pull/2405">can be compiled on Apple Silicon Macs</a>. While GitHub Actions doesn't provide CI agents for the M1 architecture, the SwiftWasm toolchain can be built locally for Apple Silicon, and we hope to provide a prebuilt distribution archive for it in some future release.</p><h3>Experimental async/await support</h3><p><a href="https://github.com/kateinoigakukun">@kateinoigakukun</a> enabled <a href="https://github.com/swiftwasm/swift/pull/2408">experimental concurrency support in SwiftWasm</a> and fixed several issues that previously prevented us from enabling <code>async</code>/<code>await</code> in development snapshots. Currently, starting with <a href="https://github.com/swiftwasm/swift/releases/tag/swift-wasm-DEVELOPMENT-SNAPSHOT-2021-01-02-a">swift-wasm-DEVELOPMENT-SNAPSHOT-2021-01-02-a</a>, the toolchain only supports a single-threaded task executor. This executor is suitable for usage in standalone WASI hosts such as Wasmer or Wasmtime. Unfortunately, it blocks the JavaScript event loop until all jobs are completed, and is unable to run any jobs created after the first event loop cycle. While this makes it unsuitable for JavaScript environments, we were able to work around that in JavaScriptKit as discussed in the next section.</p><h2>Libraries</h2><h3>JavaScriptKit</h3><p><a href="https://github.com/kateinoigakukun">@kateinoigakukun</a> started implementing <a href="https://github.com/swiftwasm/JavaScriptKit/pull/112">a Swift concurrency task executor</a> integrated with the JavaScript event loop. There are still several issues, but it's working well as a proof of concept. This experimental API allows us to utilize <code>async</code>/<code>await</code> in SwiftWasm apps for browsers and Node.js like this:</p><pre><code><span class="splash-keyword">import</span> JavaScriptEventLoop
<span class="splash-keyword">import</span> JavaScriptKit

<span class="splash-type">JavaScriptEventLoop</span>.<span class="splash-call">install</span>()
<span class="splash-keyword">let</span> fetch = <span class="splash-type">JSObject</span>.<span class="splash-property">global</span>.<span class="splash-property">fetch</span>.<span class="splash-property">function</span>!.<span class="splash-keyword">async

func</span> printZen() <span class="splash-keyword">async</span> {
  <span class="splash-keyword">let</span> result = <span class="splash-keyword">try</span>! <span class="splash-keyword">await</span> <span class="splash-call">fetch</span>(<span class="splash-string">"https://api.github.com/zen"</span>).<span class="splash-property">object</span>!
  <span class="splash-keyword">let</span> text = <span class="splash-keyword">try</span>! <span class="splash-keyword">await</span> result.<span class="splash-property">asyncing</span>.<span class="splash-property">text</span>!()
  <span class="splash-call">print</span>(text)
}

<span class="splash-type">JavaScriptEventLoop</span>.<span class="splash-call">runAsync</span> {
  <span class="splash-keyword">await</span> <span class="splash-call">printZen</span>()
}
</code></pre><h3>WebAssembly Micro Runtime</h3><p><a href="https://github.com/kateinoigakukun">@kateinoigakukun</a> published <a href="https://github.com/swiftwasm/wamr-swift">a Swift WebAssembly runtime package</a> powered by <a href="https://github.com/bytecodealliance/wasm-micro-runtime">the WebAssembly Micro Runtime project</a> (WAMR). This allows us to remove Wasmer dependency from <code>carton</code> and embed the WebAssembly runtime in the <code>carton</code> binary for use in commands such as <code>carton test</code>.</p><p>We were also able to test this package on Apple Silicon and submit <a href="https://github.com/bytecodealliance/wasm-micro-runtime/pull/480">a PR upstream</a> to make it work.</p><h3>DOMKit</h3><p>Our long-term goal is to make <a href="https://github.com/swiftwasm/DOMKit">DOMKit</a> the recommended library for type-safe interactions with Web APIs in SwiftWasm. While it's still at an early stage, we've updated it to <a href="https://github.com/swiftwasm/DOMKit/pull/3">JavaScriptKit 0.9 and added support for <code>globalThis</code></a>. <a href="https://github.com/swiftwasm/DOMKit/pull/4">In a separate PR</a> we've cleaned up unused code and fixed an event handlers crash.</p><h3>Tokamak</h3><p>With enough changes to warrant a new release, we've published <a href="https://github.com/TokamakUI/Tokamak/releases/tag/0.6.0">Tokamak 0.6.0</a>, which introduced support for the <code>Image</code> view loading images bundled as SwiftPM resources, implemented by <a href="https://github.com/j-f1">@j-f1</a>. It also adds the <code>PreferenceKey</code> protocol and related modifiers. developed by <a href="https://github.com/carson-katri">@carson-katri</a>.</p><p>Since then we've also added <a href="https://github.com/TokamakUI/Tokamak/pull/328">the <code>PreviewProvider</code> protocol</a>, <a href="https://github.com/TokamakUI/Tokamak/pull/329">an implementation of <code>TextEditor</code></a>, and updated our <a href="https://github.com/TokamakUI/Tokamak/pull/332">example code in <code>README.md</code> for script injection</a>. Additionally, a contribution from <a href="https://github.com/foscomputerservices">David Hunt</a> <a href="https://github.com/TokamakUI/Tokamak/pull/331">added missing typealiases to TokamakDOM</a> that should improve compatibility with SwiftUI, while <a href="https://github.com/j-f1">Jed Fox</a> removed <a href="https://github.com/TokamakUI/Tokamak/pull/341">redundant <code>path</code> element from SVG output</a>.</p><h2>Developer tools</h2><h3><code>carton</code></h3><p>We'd like to welcome <a href="https://github.com/thecb4">@thecb4</a>, who is the latest addition to the <code>carton</code> maintainers team! Thanks to his work, <a href="https://github.com/swiftwasm/carton/pull/191">project targets were restructured for better testability</a>, and now <a href="https://github.com/swiftwasm/carton/pull/198"><code>test</code></a>, <a href="https://github.com/swiftwasm/carton/pull/196"><code>dev</code>, and <code>bundle</code></a> commands are covered with end-to-end tests.</p><p>There's <a href="https://github.com/swiftwasm/carton/pull/195">ongoing work</a> to integrate <a href="https://github.com/swiftwasm/wamr-swift">the WAMR package</a> mentioned above with the <code>carton test</code> command. Also, <code>carton</code> now <a href="https://github.com/swiftwasm/carton/pull/189">correctly handles system target dependencies in <code>Package.swift</code></a>.</p><p>On top of that, stack traces from Chrome and Safari are <a href="https://github.com/swiftwasm/carton/pull/186">now supported in <code>carton dev</code> with proper symbol demangling</a>, thanks to the work by <a href="https://github.com/j-f1">@j-f1</a>. Additionally, <a href="https://github.com/yonihemi">@yonihemi</a> submitted <a href="https://github.com/swiftwasm/carton/pull/194">a PR which integrates <code>carton</code> with libSwiftPM</a> allowing us to reuse its model types.</p><p>Most of these changes were included in <a href="https://github.com/swiftwasm/carton/releases/tag/0.9.0">0.9.0</a> and <a href="https://github.com/swiftwasm/carton/releases/tag/0.9.1">0.9.1</a> releases published in December.</p><h3><code>webidl2swift</code></h3><p><a href="https://github.com/Apodini/webidl2swift"><code>webidl2swift</code></a> is the foundation on which our <a href="https://github.com/swiftwasm/DOMKit/">DOMKit</a> framework is built. Web API across all browsers is specified in <a href="https://en.wikipedia.org/wiki/Web_IDL">the Web IDL format</a>, which can then be parsed to generate type-safe bindings in Swift. The parser doesn't support all IDL files out there yet, but we've <a href="https://github.com/Apodini/webidl2swift/pull/10">updated dependencies and updated the code generator</a> to certain JavaScriptKit types that previously were deprecated.</p><h3>WasmTransformer</h3><p>There were a few changes to <a href="https://github.com/swiftwasm/WasmTransformer">the WasmTransformer package</a>, which we use in <code>carton</code> and intend to use in a few other dev tools. Specifically, we've <a href="https://github.com/swiftwasm/WasmTransformer/pull/12">generalized section info parsing</a> across different transformers, <a href="https://github.com/swiftwasm/WasmTransformer/pull/14">implemented a basic section size profiler</a>, and <a href="https://github.com/swiftwasm/WasmTransformer/pull/15">made the <code>TypeSection</code> type public</a> to make it easier to analyze sections of WebAssembly binaries.</p><h3>Gravity</h3><p>We're excited to announce our new developer tool enabled by WasmTransformer. <a href="https://github.com/swiftwasm/gravity">Gravity</a> is a binary code size profiler for WebAssembly built with WasmTransformer, <a href="https://developer.apple.com/xcode/swiftui/">SwiftUI</a>, and <a href="https://github.com/pointfreeco/swift-composable-architecture/">TCA</a>. It's an application for macOS that allows you to open a WebAssembly binary and view the size of different sections. Contents of some of the sections is also parsed for further analysis.</p><h2>Contributions</h2><p>A lot of our progress with SwiftWasm wouldn't be possible without payments from our GitHub Sponsors. Their contribution is deeply appreciated and allows us to spend more time on SwiftWasm projects. You can see the list of sponsors and make your contribution on <a href="https://github.com/sponsors/swiftwasm">our SwiftWasm organization sponsorship page</a>, or personal sponsorship pages of <a href="https://github.com/sponsors/carson-katri">Carson Katri</a>, <a href="https://github.com/sponsors/kateinoigakukun">Yuta Saito</a> and <a href="https://github.com/sponsors/MaxDesiatov">Max Desiatov</a>.</p><p>Thanks for reading! 👋</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftwasm.org/posts/update-04-november-2020</guid><title>What's new in SwiftWasm #4</title><description>An update on what happened in the SwiftWasm ecosystem during November 2020.</description><link>https://blog.swiftwasm.org/posts/update-04-november-2020</link><pubDate>Mon, 30 Nov 2020 14:34:00 +0000</pubDate><content:encoded><![CDATA[<h1>What's new in SwiftWasm #4</h1><h2>SwiftWasm 5.3.0 and 5.3.1 releases</h2><p>As you may have seen in <a href="https://blog.swiftwasm.org/posts/5-3-released/">our previous post</a>, we've published <a href="https://github.com/swiftwasm/swift/releases/tag/swift-wasm-5.3.0-RELEASE">our first stable release</a> recently. Shortly after that, <a href="https://github.com/flavio">@flavio</a> reported <a href="https://github.com/swiftwasm/swift/issues/2223">an issue with <code>JSONDecoder</code></a>. Following <a href="https://github.com/swiftwasm/swift/pull/2240">an investigation</a> by <a href="https://github.com/kateinoigakukun">@kateinoigakukun</a> into the root cause of the issue, we've published <a href="https://github.com/swiftwasm/swift/releases/tag/swift-wasm-5.3.1-RELEASE">SwiftWasm 5.3.1</a>, which also included updates from the upstream 5.3.1 patch release.</p><p>(If you're interested in technical details, the <code>JSONDecoder</code> issue was caused by a peculiar assumption about memory layout in Swift runtime, which wasn't applicable to WebAssembly's linear memory. <a href="https://github.com/swiftwasm/swift/pull/2240/files">Check the PR diff</a> for more details.)</p><h2>Libraries</h2><h3>JavaScriptKit</h3><p>A major update since the latest 0.8.0 release of JavaScriptKit is <a href="https://github.com/swiftwasm/JavaScriptKit/pull/102">newly added support for throwing functions</a> developed by <a href="https://github.com/kateinoigakukun">@kateinoigakukun</a>. It required an update to the JavaScript runtime part, but was an additive change to the Swift API. As we try to publish releases regularly, <a href="https://github.com/swiftwasm/JavaScriptKit/releases/tag/0.9.0">new 0.9.0 release</a> was tagged that includes this feature.</p><p><a href="https://github.com/swiftwasm/JavaScriptKit/pull/107">A PR with support for Asyncify transformation</a> was created by <a href="https://github.com/yonihemi">@yonihemi</a>. It allows calling asynchronous JavaScript APIs with Swift code that looks as plain synchronous code, but through proper suspension that doesn't block browser rendering. The PR has some implications on how we build things, especially as it requires a specific optimizer transformation. It is still in the draft stage, and you're welcome to contribute to the ongoing discussion.</p><h3>OpenCombine</h3><p>We still use <a href="https://github.com/TokamakUI/OpenCombine">a fork of OpenCombine</a> in Tokamak due to our custom implementation of the <code>ObservableObject</code> protocol. In addition to that, our fork also contained some changes to the package manifest to make it build with SwiftWasm, but they made it incompatible with non-Wasm platforms. This issue was <a href="https://github.com/OpenCombine/OpenCombine/pull/191">resolved in the upstream OpenCombine repository</a>, which reduced the amount of customizations we apply, and brings us closer to using the upstream repository as is.</p><h3>OpenCombineJS</h3><p>With progress on OpenCombine, it was time to publish the first version of <a href="https://github.com/swiftwasm/OpenCombineJS">OpenCombineJS</a>. Its code didn't change recently, but parts of it were used in Tokamak already, which gave us confidence that it was reliable enough to be released in a separate library for wider use. It currently doesn't contain much code, but this basic functionality should be enough for basic integration of JavaScriptKit types and OpenCombine.</p><h3>Tokamak</h3><p>Following <a href="https://github.com/TokamakUI/Tokamak/releases/tag/0.5.0">the 0.5.0 release</a>, which added support for the latest <code>carton</code>, we published <a href="https://github.com/TokamakUI/Tokamak/releases/tag/0.5.1">a small 0.5.1 patch</a> with support for editing Tokamak projects in Xcode with working autocomplete. Not long after that <a href="https://github.com/TokamakUI/Tokamak/pull/301">an important bugfix</a> landed in <a href="https://github.com/TokamakUI/Tokamak/releases/tag/0.5.2">0.5.2</a>, which fixed an issue with display order of updated views in the DOM renderer. A few weeks later another <a href="https://github.com/TokamakUI/Tokamak/releases/tag/0.5.3">bugfix release</a> was published as 0.5.3. In this update Tokamak now internally relies on the aforementioned OpenCombineJS library instead of providing its own <code>JSScheduler</code> type conforming to Combine's <code>Scheduler</code>. More importantly, it fixes <a href="https://github.com/TokamakUI/Tokamak/issues/287">a bug with <code>Toggle</code> not being updated</a> after resetting it from a binding.</p><h2>Developer tools</h2><h3>WasmTransformer</h3><p><a href="https://github.com/kateinoigakukun">@kateinoigakukun</a> <a href="https://github.com/swiftwasm/WasmTransformer/commit/d79d945731e03a10cb2806cbafc0be0113a2b9bf">implemented</a> a <code>stripCustomSections</code> transformation in <a href="https://github.com/swiftwasm/WasmTransformer">the <code>WasmTransformer</code> library</a>. <a href="https://webassembly.github.io/spec/core/appendix/custom.html">According to the spec</a>, data in custom sections should not contribute to observed behavior of a given binary. In the case of binaries produced by SwiftWasm, custom sections contain debugging information that can now be stripped with</p><p><code>WasmTransformer</code>.</p><h3><code>carton</code></h3><p>Previously, custom sections were stripped to reduce final binary size as a build step in `carton bundle<code> with the </code>wasm-strip` utility from <a href="https://github.com/webassembly/wabt">WABT</a>. Thanks to the new transformation in <code>WasmTransformer</code>, WABT is no longer needed as a dependency of <code>carton</code>, which makes installation for our end users simpler and faster.</p><p>Initial support for presenting crash stack traces directly in <code>carton</code> has been completed, starting with <a href="https://github.com/swiftwasm/carton/pull/162">Firefox support</a>. Support for more browsers will be added in separate PRs.</p><p>There was also work on <a href="https://github.com/swiftwasm/carton/pull/171">file downloader cleanup</a>, <a href="https://github.com/swiftwasm/carton/pull/173">support for browser testing</a>, and <a href="https://github.com/swiftwasm/carton/pull/176">simpler URLs for main bundle resources</a>. As soon as these are merged, a new version of <code>carton</code> will be tagged that will use the latest 5.3.1 release of SwiftWasm.</p><h2>Contributions</h2><p>A lot of the progress wouldn't be possible without payments from our GitHub Sponsors. Their contribution is deeply appreciated and allows us to spend more time on SwiftWasm projects. You can see the list of sponsors and make your contribution on the sponsorship pages of <a href="https://github.com/sponsors/carson-katri">Carson Katri</a>, <a href="https://github.com/sponsors/kateinoigakukun">Yuta Saito</a> and <a href="https://github.com/sponsors/MaxDesiatov">Max Desiatov</a>.</p><p>Thanks for reading! 👋</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftwasm.org/posts/5-3-released</guid><title>The first stable toolchain release of SwiftWasm!</title><description>Our stable 5.3 release of the toolchain is now available</description><link>https://blog.swiftwasm.org/posts/5-3-released</link><pubDate>Tue, 10 Nov 2020 00:39:00 +0000</pubDate><content:encoded><![CDATA[<h1>The first stable toolchain release of SwiftWasm!</h1><h2>Overview</h2><p>This is the <a href="https://github.com/swiftwasm/swift/releases/tag/swift-wasm-5.3.0-RELEASE">first public release</a> of SwiftWasm toolchain, available as a signed .pkg installer for macOS. Also via swiftenv-compatible archives and <a href="https://github.com/orgs/swiftwasm/packages/container/package/swift">Docker for Intel-based Ubuntu 18.04 and 20.04</a>. Our focus is on providing essential Swift features for the WebAssembly platform. Distributions supplied with this release are our most stable yet, and no breaking changes are expected for 5.3 releases anymore.</p><p>This release includes the Swift for WebAssembly compiler, the standard and core libraries (excluding Dispatch), JavaScript interoperation library, UI library, build tool and CI support.</p><h2>The standard library and core libraries</h2><p>The Swift standard library is fully available on WebAssembly platform.</p><p>The standard library right now depends on WASI, which is a modular system interface for WebAssembly. We use the <a href="https://github.com/WebAssembly/wasi-libc">wasi-libc</a> implementation, which you can also use in your Swift apps with a simple <code>import WASILibc</code> statement. However, we are going to make the WASI dependency optional in the future.</p><h3>Foundation / XCTest</h3><p>Foundation and XCTest are also available on WebAssembly, but in a limited capacity.</p><p>Please refer to our <a href="https://book.swiftwasm.org/getting-started/foundation.html">Foundation</a> and <a href="https://book.swiftwasm.org/getting-started/testing.html">XCTest</a> guides for more details.</p><h2>JavaScript interoperation library</h2><p><a href="https://github.com/swiftwasm/JavaScriptKit">JavaScriptKit</a> is a Swift library to interact with JavaScript through WebAssembly.</p><p>You can use any JavaScript API from Swift with this library. Here's a quick example of JavaScriptKit usage in a browser app:</p><pre><code><span class="splash-keyword">import</span> JavaScriptKit

<span class="splash-keyword">let</span> document = <span class="splash-type">JSObject</span>.<span class="splash-property">global</span>.<span class="splash-property">document</span>

<span class="splash-keyword">var</span> divElement = document.<span class="splash-call">createElement</span>(<span class="splash-string">"div"</span>)
divElement.<span class="splash-property">innerText</span> = <span class="splash-string">"Hello, world"</span>
<span class="splash-keyword">_</span> = document.<span class="splash-property">body</span>.<span class="splash-call">appendChild</span>(divElement)
</code></pre><p>You can learn more from our <a href="https://book.swiftwasm.org/getting-started/javascript-interop.html">JavaScript interop guide</a>.</p><h2>UI library</h2><p><a href="https://tokamak.dev">The Tokamak UI framework</a> is a cross-platform implementation of the SwiftUI API. We currently only support WebAssembly/DOM with a lot of API parts covered, and static HTML rendering on macOS/Linux. Get started with our <a href="https://book.swiftwasm.org/getting-started/browser-app.html">browser apps guide</a> that lists necessary steps to create a simple browser app with Tokamak.</p><h2>All-in-one builder, test runner, and bundler for SwiftWasm</h2><p><a href="https://github.com/swiftwasm/carton"><code>carton</code></a> is a build tool designed specifically for SwiftWasm. It is similar to webpack.js, but no configuration and dependencies (except Swift itself to build <code>carton</code>) are required. It's also our recommended way to install SwiftWasm as it downloads and unpacks our toolchain and SDK automatically for you.</p><h2>CI support</h2><p>We maintain a <a href="https://github.com/swiftwasm/swiftwasm-action">GitHub Action</a> that includes the SwiftWasm toolchain and <code>carton</code> for your continuous integration needs.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftwasm.org/posts/update-03-october-2020</guid><title>What's new in SwiftWasm #3</title><description>An update on what happened in the SwiftWasm ecosystem during the second half of October 2020.</description><link>https://blog.swiftwasm.org/posts/update-03-october-2020</link><pubDate>Fri, 30 Oct 2020 14:34:00 +0000</pubDate><content:encoded><![CDATA[<h1>What's new in SwiftWasm #3</h1><h2>Examples and guides</h2><p><a href="https://github.com/hassan-shahbazi">@hassan-shahbazi</a> wrote <a href="https://medium.com/@h.shahbazi/the-power-of-swift-web-assembly-part-1-fdfa4e9134ee">a 3 part guide</a> about his experience when integrating SwiftWasm apps within Go apps through <a href="https://wasmer.io/">Wasmer</a>. He also published <a href="https://github.com/hassan-shahbazi/swiftwasm-go">example code accompanying the articles</a> on GitHub. It's a great introduction to SwiftWasm that doesn't assume much prior knowledge, and could be useful if you'd like to integrate binaries produced by SwiftWasm in a host application.</p><p><a href="https://github.com/johngarrett">@johngarrett</a> published an interactive <a href="https://garrepi.dev/swal">"Swift, Wasm, and Algorithms"</a> documentation page. It is a demo of the recently released <a href="https://github.com/apple/swift-algorithms">Swift Algorithms</a> package where you can tweak parameters for some of the functions and observe results directly in the browser. Not all of the functions are fully interactive now, but it's a great proof of concept for interactive documentation websites one could build with SwiftWasm. Its source code is <a href="https://github.com/johngarrett/swal-wasm">available on GitHub</a>.</p><h2>SwiftWasm documentation</h2><p>Two new sections were added to <a href="https://book.swiftwasm.org/">the SwiftWasm book</a> that clarify <a href="https://book.swiftwasm.org/getting-started/foundation.html">limitations of Foundation</a>, and <a href="https://book.swiftwasm.org/getting-started/testing.html">recommended ways to use XCTest</a> with the SwiftWasm SDK.</p><h2>Developer tools</h2><h3>WasmTransformer</h3><p><a href="https://github.com/kateinoigakukun">@kateinoigakukun</a> published <a href="https://github.com/swiftwasm/WasmTransformer">a pure Swift implementation of a transformer for Wasm binaries</a>. This resolves <a href="https://github.com/swiftwasm/JavaScriptKit/issues/97">the issue with <code>i64</code> to <code>BigInt</code> incompatibility in Safari</a>, as we can now <a href="https://github.com/swiftwasm/carton/pull/131">integrate an appropriate transformation</a> into our build pipeline in <code>carton</code>. The <code>WasmTransformer</code> library is still at an early stage, but it shows that Swift is suitable for low-level code just as well as C/C++ or Rust.</p><h3><code>carton</code></h3><p>In addition to the WasmTransfomer integration mentioned above, <code>carton test</code> now <a href="https://github.com/swiftwasm/carton/pull/130">passes the <code>--enable-test-discovery</code> flag</a> to <code>swift test</code> by default, which means that you no longer need to maintain <code>LinuxMain.swift</code> and <code>XCTestManifests.swift</code> files in your test suites.</p><p>A <code>Dockerfile</code> <a href="https://github.com/swiftwasm/carton/pull/136">was added to the <code>carton</code> repository</a>, and you can now run <code>carton</code> in a Docker container, which also has the toolchain and other dependencies preinstalled. You can pull the Docker image with a simple command:</p><pre><code>docker pull ghcr.<span class="splash-property">io</span>/swiftwasm/carton:latest
</code></pre><p>Additionally, <code>carton</code> gained <a href="https://github.com/swiftwasm/carton/pull/134">support for Ubuntu 20.04</a>, and now also has a CI job to test compatibility with it during development. Similarly, <a href="https://github.com/swiftwasm/carton/pull/132">a CI job for macOS Big Sur on Intel platforms</a> was added as soon as GitHub Actions started providing appropriate CI images.</p><p>After these changes were merged <a href="https://github.com/swiftwasm/carton/releases/tag/0.7.0"><code>carton</code> 0.7 was released</a> and is now available via Homebrew on macOS.</p><p>After the release, <a href="https://github.com/carson-katri">@carson-katri</a> merged a PR that greatly improves command-line experience with <code>carton test</code>. It builds on his previous work on <code>carton dev</code> with compiler diagnostics parsing and error highlighting. With this new change XCTest output is also parsed, reformatted, and highlighted in a nice summary view.</p><br /><img src="https://blog.swiftwasm.org/images/update-03-carton-test-summary.png" alt="Pretty-printed test summary in &#96;carton&#96;" width="100%"/><br /><br /><img src="https://blog.swiftwasm.org/images/update-03-carton-test-errors.png" alt="Pretty-printed test errors in &#96;carton&#96;" width="100%"/><br /><br /><h3>GitHub Actions</h3><p>Thanks to the fact that <code>carton</code> is now available in a Docker image, it can now be used in our <a href="https://github.com/swiftwasm/swiftwasm-action"><code>swiftwasm-action</code></a>, which previously only contained the plain SwiftWasm toolchain without any additional tools. This action now invokes <code>carton test</code> by default on a given repository during a GitHub Actions run, but you can customize it and call any other command. For example, you could run <code>carton bundle</code> with <code>swiftwasm-action</code>, and then use the <a href="https://github.com/peaceiris/actions-gh-pages"><code>peaceiris/actions-gh-pages</code></a> step to deploy the resulting bundle to <a href="https://pages.github.com/">GitHub Pages</a>.</p><h2>Libraries</h2><h2>JavaScriptKit</h2><p><a href="https://github.com/swiftwasm/JavaScriptKit/releases/tag/0.8.0">JavaScriptKit 0.8.0</a> has been released. As mentioned in our previous issue, it introduces a few enhancements and deprecations, and is a recommended upgrade for all users.</p><h3>Tokamak</h3><p><a href="https://github.com/Cosmo">@Cosmo</a> pointed out that SwiftUI apps should change almost the whole palette when switching between color schemes. As he discovered when working on his <a href="https://github.com/Cosmo/OpenSwiftUI/">OpenSwiftUI</a> and <a href="https://github.com/Cosmo/SwiftUIEmbedded">SwiftUIEmbedded</a> projects, the implementation of the <code>Color</code> type is much more subtle than we originally anticipated. This was resolved by <a href="https://github.com/carson-katri">@carson-katri</a> in <a href="https://github.com/TokamakUI/Tokamak/issues/291">#291</a> and is now available in the <code>main</code> branch. The plan is to merge a few more changes and bugfixes, and to tag a new release of Tokamak soon after that.</p><h2>Upstream PRs</h2><h3>Swift Driver</h3><p><a href="https://github.com/owenv">@owenv</a> merged <a href="https://github.com/apple/swift-driver/pull/315">a PR to the Swift Driver project</a> implementing WebAssembly toolchain support. This mirrors our existing <a href="https://github.com/swiftwasm/swift/blob/swiftwasm/lib/Driver/WebAssemblyToolChains.cpp">C++ implementation in the legacy driver</a>, and it's great that the new parts of the Swift compiler rewritten in Swift are going to support WebAssembly too. While Swift Driver isn't enabled in any toolchain by default, we're definitely going to enable it at some point in the future as soon as it seems to be stable enough for us.</p><h3>SwiftPM and Swift Tools Support Core</h3><p><a href="https://github.com/kateinoigakukun">@kateinoigakukun</a> submitted <a href="https://github.com/apple/swift-package-manager/pull/3001">a PR to SwiftPM</a> that propagates the <code>-static-stdlib</code> flag correctly to the compiler driver. After it was merged, we were able <a href="https://github.com/swiftwasm/carton/pull/141">to remove a bit of code</a> that generated SwiftPM destination files to ensure correct linking, and this is no longer needed thanks to the upstream changes.</p><p><a href="https://github.com/sponsors/MaxDesiatov">@MaxDesiatov</a> merged <a href="https://github.com/apple/swift-tools-support-core/pull/153">a PR to Swift TSC</a> that adds <code>.wasm</code> file extension to WebAssembly binaries produced by SwiftPM. This extension was previously missing, which didn't make it obvious enough that these binaries can't be run without passing them to an appropriate WebAssembly host.</p><h2>Toolchain/SDK work</h2><p>In preparation for the 5.3.0 release of SwiftWasm, our macOS archives are <a href="https://github.com/swiftwasm/swift/pull/2029">now distributed as signed <code>.pkg</code> installers</a>. Also need to mention that the toolchain archive is now available for Ubuntu 20.04, and all archive files now have consistent naming that includes the full OS name and CPU architecture. This will make it much easier for us to distribute ARM64 builds and builds for other Linux distributions in the future.</p><p><a href="https://github.com/swiftwasm/swift/pull/2125">Another change</a> to be included in 5.3 snapshots would add <code>.wasm</code> file extension to binaries reflecting aforementioned upstream PRs.</p><p>Additionally, we found that it's currently not possible to build C++ code that includes certain headers with SwiftWasm 5.3 snapshots. As some Swift libraries do have C++ targets as their dependencies, <a href="https://github.com/swiftwasm/swift/pull/2127">it would be great if this is fixed</a> before SwiftWasm 5.3.0 is tagged.</p><p>We'll be using latest 5.3 snapshots in our apps and libraries for some time, and will tag 5.3.0 when we have enough confidence there are no major issues.</p><p>The <code>wasm-DEVELOPMENT-SNAPSHOT</code> archives will continue to be tagged on a regular basis to serve as a preview of the next version of SwiftWasm, but are not recommended for general use.</p><h2>Contributions</h2><p>A lot of the progress wouldn't be possible without payments from our GitHub Sponsors. Their contribution is deeply appreciated and allows us to spend more time on SwiftWasm projects. You can see the list of sponsors and make your contribution on the sponsorship pages of <a href="https://github.com/sponsors/carson-katri">Carson Katri</a>, <a href="https://github.com/sponsors/kateinoigakukun">Yuta Saito</a> and <a href="https://github.com/sponsors/MaxDesiatov">Max Desiatov</a>.</p><p>Thanks for reading! 👋</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftwasm.org/posts/update-02-october-2020</guid><title>What's new in SwiftWasm #2</title><description>An update on what happened in the SwiftWasm ecosystem during the first half of October 2020.</description><link>https://blog.swiftwasm.org/posts/update-02-october-2020</link><pubDate>Wed, 14 Oct 2020 14:34:00 +0000</pubDate><content:encoded><![CDATA[<h1>What's new in SwiftWasm #2</h1><p>Welcome to the second SwiftWasm update! To make the updates flow steady, we're trying to publish them fortnightly now. Let us know what you think of this new cadence. And here's a gentle reminder that this blog is fully open-source, so if you spot a typo, an error, a broken link, or have any other feedback, please feel free to file it <a href="https://github.com/swiftwasm/blog.swiftwasm.org">in our <code>blog.swiftwasm.org</code> GitHub repository</a>.</p><h2>SwiftWasm team updates</h2><p>We would like to welcome <a href="https://github.com/yonihemi">@yonihemi</a> to the SwiftWasm team who joined us in the beginning of October. After the previous contributions he made to <a href="https://carton.dev"><code>carton</code></a> it made perfect sense to expand our team. As always, we invite everyone to contribute to any of our repositories, and it doesn't require much prior experience with SwiftWasm if any at all. Bug fixes, feature additions, improved documentation and related changes are very much appreciated and allow our ecosystem to grow even more!</p><h2>SwiftWasm documentation</h2><p>Our documentation was restructured and updated, and is now hosted on the <a href="https://book.swiftwasm.org"><code>book.swiftwasm.org</code></a> domain. Please file all feedback in the <a href="https://github.com/swiftwasm/swiftwasm-book"><code>swiftwasm-book</code></a> repository on GitHub, which hosts its source code.</p><h2>JavaScriptKit</h2><p><a href="https://github.com/swiftwasm/JavaScriptKit">JavaScriptKit</a> had a few important updates in October so far. Most importantly, now that PR <a href="https://github.com/swiftwasm/JavaScriptKit/pull/91">#91</a> by <a href="https://github.com/kateinoigakukun">@kateinoigakukun</a> was merged, JavaScriptKit no longer uses unsafe flags in its <code>Package.swift</code>. The use of unsafe flags was a big problem for us, as it breaks dependency resolution due to strict checks that SwiftPM applies. If any package in your dependency tree contains unsafe flags, you can no longer depend on its semantic version, or a semantic version of any other package that depends on it.</p><p>So far we were able to work around that with a hardcoded check for JavaScriptKit in our fork of SwiftPM. This was obviously a very ugly hack, but the biggest downside of that approach was that you couldn't depend on any package that had a semantic version dependency on JavaScriptKit in upstream Swift toolchains. That meant that libraries like <a href="https://tokamak.dev">Tokamak</a> could not be built for macOS or Linux. And while the WebAssembly DOM renderer in Tokamak is the most useful module right now, this prevented static HTML rendering from working on macOS and Linux.</p><p>Another issue we had with JavaScriptKit is <a href="https://github.com/swiftwasm/JavaScriptKit/issues/87">the naming of <code>JSValueConstructible</code> and <code>JSValueConvertible</code></a> protocols. These protocols are used for conversions between <code>JSValue</code> references and arbitrary Swift values. In practice it wasn't always clear which of these protocols was responsible for a specific conversion. After some deliberation, these were renamed to <code>ConstructibleFromJSValue</code> and <code>ConvertibleToJSValue</code> respectively in <a href="https://github.com/swiftwasm/JavaScriptKit/pull/88">#88</a>.</p><p><a href="https://github.com/swiftwasm/JavaScriptKit/pull/98">A proposal PR</a> was submitted by <a href="https://github.com/kateinoigakukun">@kateinoigakukun</a> to enable unsafe force unwrapping of dynamic member properties in JavaScript by default. That is, it would allow this</p><pre><code><span class="splash-keyword">let</span> document = <span class="splash-type">JSObject</span>.<span class="splash-property">global</span>.<span class="splash-property">document</span>
<span class="splash-keyword">let</span> foundDivs = document.<span class="splash-call">getElementsByTagName</span>(<span class="splash-string">"div"</span>)
</code></pre><p>in addition to the currently available explicit style with force unwrapping:</p><pre><code><span class="splash-keyword">let</span> document = <span class="splash-type">JSObject</span>.<span class="splash-property">global</span>.<span class="splash-property">document</span>.<span class="splash-property">object</span>!
<span class="splash-keyword">let</span> foundDivs = document.<span class="splash-property">getElementsByTagName</span>!(<span class="splash-string">"div"</span>).<span class="splash-property">object</span>!
</code></pre><p>The key thing to note is that the first option is still dynamically typed and these options are equivalent in their behavior. If you address a missing property on your JavaScript object with this API, your SwiftWasm app will crash. One possible reasoning for this change is that this would follow the approach of <a href="https://github.com/tensorflow/swift#why-swift-for-tensorflow">PythonKit and Swift for TensorFlow</a>, and improve readability and ease of use for newcomers. We encourage you to voice your opinion in PR comments to give us more feedback on this proposal.</p><p><a href="https://github.com/swiftwasm/JavaScriptKit/issues/97">An issue was raised</a> by <a href="https://github.com/yonihemi">@yonihemi</a> this week on our JavaScriptKit repository about <code>i64</code> Wasm function return type support in Safari. The reason for it is that <a href="https://webassembly.org/roadmap/">Safari is the only major browser</a> that <a href="https://bugs.webkit.org/show_bug.cgi?id=213528">doesn't support</a> <a href="https://github.com/WebAssembly/JS-BigInt-integration">Wasm <code>i64</code> to <code>BigInt</code> conversion</a>. Unfortunately, there are many APIs that require this conversion to work, and it's unclear yet if this can be polyfilled on the JavaScript side at all. Currently it looks like we need to apply some transformations to binaries produced by SwiftWasm to resolve this issue, but it remains to be seen how well that would work in practice.</p><h2>Tokamak</h2><p>Tokamak didn't see major updates recently, but we've received some important bug reports during the last few weeks. Firstly, there's <a href="https://github.com/TokamakUI/Tokamak/issues/285">an edge case with <code>Picker</code> views</a> that use <code>\.self</code> as an identifier keypath. Secondly, <a href="https://github.com/TokamakUI/Tokamak/issues/287"><code>Toggle</code> binding is not reset</a> after its value changes outside of the view. Many thanks to <a href="https://github.com/rbartolome">@rbartolome</a> for the extensive testing he's given and for reporting these issues!</p><h2>Developer tools</h2><p>In the first half of October <a href="https://github.com/yonihemi">@yonihemi</a> submitted two important quality-of-life improvements to <code>carton</code>:</p><ul><li>Allow changing dev server's port (<a href="https://github.com/swiftwasm/carton/pull/116">#116</a>).</li><li>Automatically open a browser window when dev server starts (<a href="https://github.com/swiftwasm/carton/pull/117">#117</a>).</li></ul><p>There's also an open "Pretty print diagnostics" PR <a href="https://github.com/swiftwasm/carton/pull/122">#112</a> submitted by <a href="https://github.com/carson-katri">@carson-katri</a>. It does some magic with diagnostic messages emitted by the Swift compiler, highlights relevant lines of code and formats all of it nicely. You can check out a preview on this screenshot:</p><img src="https://blog.swiftwasm.org/images/update-02-carton.png" alt="Pretty-printed compiler diagnostics in &#96;carton&#96;" width="100%"/><h2>Upstream PRs</h2><p>Not much upstreaming work happened in October yet, but there was some progress in <a href="https://github.com/apple/sourcekit-lsp/pull/330">adding cross-compilation support to SourceKit-LSP</a>. We are also preparing a 5.3 SwiftWasm snapshot with this patch, which will enable this new <code>--destination</code> option on SourceKit-LSP. When that works, we want <code>carton</code> to infer a value for this option and launch it automatically for you when needed. This is all to make auto-complete work correctly for your SwiftWasm apps and libraries in VSCode or any other LSP-supporting editor or IDE.</p><h2>Toolchain/SDK work</h2><p>Most of the work in preparation for the 5.3.0 release of SwiftWasm has been done. Now that it's possible to build JavaScriptKit without unsafe flags, and with IndexStoreDB and SourceKit-LSP shipping with the latest 5.3.0 snapshots, only the last round of testing is needed before tagging a release candidate. The rest of our work on the SwiftWasm toolchain and SDK was mostly related to fixing a build breakage caused by updates to GitHub Actions runner images and resolving conflicts with upstream code.</p><h2>Contributions</h2><p>A lot of the progress wouldn't be possible without payments from our GitHub Sponsors. Their contribution is deeply appreciated and allows us to spend more time on SwiftWasm projects. You can see the list of sponsors and make your contribution on the sponsorship pages of <a href="https://github.com/sponsors/carson-katri">Carson Katri</a>, <a href="https://github.com/sponsors/kateinoigakukun">Yuta Saito</a> and <a href="https://github.com/sponsors/MaxDesiatov">Max Desiatov</a>.</p><p>Thanks for reading! 👋</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftwasm.org/posts/september-2020</guid><title>September 2020 Update</title><description>An update on what happened in the SwiftWasm ecosystem during September 2020.</description><link>https://blog.swiftwasm.org/posts/september-2020</link><pubDate>Wed, 30 Sep 2020 14:34:00 +0000</pubDate><content:encoded><![CDATA[<h1>September 2020 Update</h1><p>Welcome to the SwiftWasm blog! The amount of work happening in <a href="https://github.com/swiftwasm">the SwiftWasm ecosystem</a> is growing, so we decided to start publishing blog updates to give you an overview of what happened recently. This update for September is big enough to be split into different sections for each area of our work, so let's get started. 🙂</p><h2>Libraries</h2><p><a href="https://github.com/swiftwasm/JavaScriptKit/releases/tag/0.7.0">JavaScriptKit 0.7</a> has been released. It adds multiple new types bridged from JavaScript, namely <code>JSError</code>, <code>JSDate</code>, <code>JSTimer</code> (which corresponds to <code>setTimeout</code>/<code>setInterval</code> calls and manages closure lifetime for you), <code>JSString</code> and <code>JSPromise</code>. We now also have <a href="https://swiftwasm.github.io/JavaScriptKit/">documentation published automatically</a> for the <code>main</code> branch.</p><p>New features of JavaScriptKit allowed us to start working on closer integration with <a href="https://github.com/OpenCombine/OpenCombine">OpenCombine</a>. The current progress is available in the new <a href="https://github.com/swiftwasm/OpenCombineJS">OpenCombineJS</a> repository, and we plan to tag a release for it soon. At the moment it has a <code>JSScheduler</code> class wrapping <code>JSTimer</code> that implements <a href="https://developer.apple.com/documentation/combine/scheduler">the <code>Scheduler</code> protocol</a>, enabling you to use <code>debounce</code> and other time-based operators. Additionally, OpenCombineJS now provides a helper <code>publisher</code> property on <code>JSPromise</code>, which allows you to integrate any promise-based API with an OpenCombine pipeline.</p><p>We also saw a lot of great progress with <a href="https://github.com/swiftwasm/DOMKit">DOMKit</a> in September thanks to the outstanding work by <a href="https://jedfox.com/">Jed Fox</a> and <a href="https://github.com/Unkaputtbar">@Unkaputtbar</a>, which was unblocked by the recent additions to JavaScriptKit. With DOMKit we're going to get type-safe access to the most common browser DOM APIs. It will be expanded in the future to support even more features that currently are only available via JavaScriptKit through force unwrapping and dynamic casting.</p><p>That is, compare the current API you get with JavaScriptKit:</p><pre><code><span class="splash-keyword">import</span> JavaScriptKit

<span class="splash-keyword">let</span> document = <span class="splash-type">JSObject</span>.<span class="splash-property">global</span>.<span class="splash-property">document</span>.<span class="splash-property">object</span>!

<span class="splash-keyword">let</span> divElement = document.<span class="splash-property">createElement</span>!(<span class="splash-string">"div"</span>).<span class="splash-property">object</span>!
divElement.<span class="splash-property">innerText</span> = <span class="splash-string">"Hello, world"</span>
<span class="splash-keyword">let</span> body = document.<span class="splash-property">body</span>.<span class="splash-property">object</span>!
<span class="splash-keyword">_</span> = body.<span class="splash-property">appendChild</span>!(divElement)
</code></pre><p>to an equivalent snippet that could look like this with DOMKit:</p><pre><code><span class="splash-keyword">import</span> DOMKit

<span class="splash-keyword">let</span> document = global.<span class="splash-property">document</span>

<span class="splash-keyword">let</span> divElement = document.<span class="splash-call">createElement</span>(<span class="splash-string">"div"</span>)
divElement.<span class="splash-property">innerText</span> = <span class="splash-string">"Hello, world"</span>
document.<span class="splash-property">body</span>.<span class="splash-call">appendChild</span>(divElement)
</code></pre><p>Lastly on the libraries front, <a href="https://github.com/TokamakUI/Tokamak/releases">Tokamak 0.4</a> is now available, enabling compatibility with the new version of JavaScriptKit, and utilizing the aforementioned <code>JSScheduler</code> implementation.</p><h2>Developer tools</h2><p>Following the new 0.7 release of JavaScriptKit, <a href="https://github.com/swiftwasm/carton/releases/tag/0.6.0"><code>carton</code> 0.6</a> has been tagged, shipping with the appropriate JavaScriptKit runtime compatible with the new release. It also includes support for the new <code>carton bundle</code> command that produces a directory with optimized build output ready for deployment on a CDN or any other server. Notably, both <code>carton bundle</code> and <code>carton dev</code> support <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0271-package-manager-resources.md">SwiftPM package resources</a>, allowing you to include additional static content in your SwiftWasm apps. These could be styles, scripts, images, fonts, or whatever other data you'd like to ship with your app.</p><p>This version of <code>carton</code> also ships with the latest version of <a href="https://github.com/wasmerio/wasmer-js/">wasmer.js</a>, which fixes compatibility with recently released Safari 14.</p><h2>Toolchain/SDK work</h2><p>The upstream Swift toolchain has switched to <a href="http://llvm.org">LLVM</a> 11 in the <code>main</code> branch, which caused a substantial amount of conflicts in our forked repositories. Resolving the conflicts and making sure everything builds properly consumed a lot of our time in September. You could've noticed that the previously steady stream of nighly development snapshots stalled for most of September, but it resumed starting with <code>wasm-DEVELOPMENT-SNAPSHOT-2020-09-20-a</code>.</p><p>As for the 5.3 branch, with the upstream Swift 5.3.0 release now generally available, we're now preparing a stable SwiftWasm 5.3.0 release. It is based off upstream 5.3.0 with our patches applied to the toolchain and the SDK. <a href="https://github.com/swiftwasm/swift/issues/1759">We've created a checklist</a> that allows us to track the progress of this effort.</p><p>One of the issues we wanted to resolve before tagging SwiftWasm 5.3.0 is the inconsistency between WASI and Glibc APIs. While parts of those look and works the same, the rest are significantly different. Because of this, in subsequent snapshots our users need to use <code>import WASILibc</code> instead of <code>import Glibc</code> if they need to access to libc on the WASI platform. This has already landed in the <code>swiftwasm-release/5.3</code> branch with <a href="https://github.com/swiftwasm/swift/pull/1773">swiftwasm/swift#1773</a> and is available in <code>wasm-5.3-SNAPSHOT-2020-09-23-a</code> or later. It was also implemented in the main <code>swiftwasm</code> branch in <a href="https://github.com/swiftwasm/swift/pull/1832">swiftwasm/swift#1832</a>, all thanks to the amazing work by <a href="https://github.com/sponsors/kateinoigakukun">Yuta Saito</a>.</p><h2>Upstream PRs</h2><p>The divergence between the SwiftWasm toolchain/SDKs and their upstream version is still significant and causes regular conflicts that we have to resolve manually. We're working on making our changes available upstream, but this takes a lot of time, as upstream toolchain and SDK PRs need high level of polish to be accepted. Here's a list of PRs that had some progress in September:</p><h3>Foundation</h3><ul><li>Add locking primitives for <code>TARGET_OS_WASI</code> in <code>CFLocking.h</code> <a href="https://github.com/apple/swift-corelibs-foundation/pull/2867">apple/swift-corelibs-foundation#2867</a>. <strong>Status: merged.</strong></li><li>Add support for WASI in <code>CFInternal.h</code> <a href="https://github.com/apple/swift-corelibs-foundation/pull/2872">apple/swift-corelibs-foundation#2872</a>. <strong>Status: merged.</strong></li><li>Add WASI support in <code>CoreFoundation_Prefix.h</code> <a href="https://github.com/apple/swift-corelibs-foundation/pull/2873">apple/swift-corelibs-foundation#2873</a>. <strong>Status: merged.</strong></li><li>Add support for WASI in <code>CFDate.c</code> <a href="https://github.com/apple/swift-corelibs-foundation/pull/2880">apple/swift-corelibs-foundation#2880</a>. <strong>Status: in review.</strong></li></ul><h3>SwiftPM</h3><ul><li>Propagate PATH to UserToolchain to fix sysroot search <a href="https://github.com/apple/swift-package-manager/pull/2936">apple/swift-package-manager#2936</a>. <strong>Status: merged.</strong></li></ul><h2>Contributions</h2><p>We hope you can contribute to the SwiftWasm ecosystem, either to any of the projects listed above, or with your own libraries and apps that you built. We'd be very happy to feature your open-source work in our next update! Our <a href="https://github.com/swiftwasm/swiftwasm.org"><code>swiftwasm.org</code> website</a> and <a href="https://github.com/swiftwasm/blog.swiftwasm.org">this blog</a> are open-source, so please feel free to open an issue or a pull request with a link to your work related to SwiftWasm.</p><p>A lot of the progress wouldn't be possible without payments from our GitHub Sponsors. Their contribution is deeply appreciated and allows us to spend more time on SwiftWasm projects. You can see the list of sponsors and make your contribution on the sponsorship pages of <a href="https://github.com/sponsors/kateinoigakukun">Yuta Saito</a> and <a href="https://github.com/sponsors/MaxDesiatov">Max Desiatov</a>.</p><p>Thanks for reading! 👋</p>]]></content:encoded></item></channel></rss>