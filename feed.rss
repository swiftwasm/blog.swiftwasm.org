<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>SwiftWasm Blog</title><description></description><link>https://blog.swiftwasm.org</link><language>en</language><lastBuildDate>Wed, 14 Oct 2020 17:40:51 +0000</lastBuildDate><pubDate>Wed, 14 Oct 2020 17:40:51 +0000</pubDate><ttl>250</ttl><atom:link href="https://blog.swiftwasm.org/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://blog.swiftwasm.org/posts/update-02-october-2020</guid><title>What's new in SwiftWasm #2</title><description>An update on what happened in the SwiftWasm ecosystem during the first half of October 2020.</description><link>https://blog.swiftwasm.org/posts/update-02-october-2020</link><pubDate>Wed, 14 Oct 2020 14:34:00 +0000</pubDate><content:encoded><![CDATA[<h1>What's new in SwiftWasm #2</h1><p>Welcome to the second SwiftWasm update! To make the updates flow steady, we're trying to publish them fortnightly now. Let us know what you think of this new cadence. And here's a gentle reminder that this blog is fully open-source, so if you spot a typo, an error, a broken link, or have any other feedback, please feel free to file it <a href="https://github.com/swiftwasm/blog.swiftwasm.org">in our <code>blog.swiftwasm.org</code> GitHub repository</a>.</p><h2>SwiftWasm team updates</h2><p>We would like to welcome <a href="https://github.com/yonihemi">@yonihemi</a> to the SwiftWasm team who joined us in the beginning of October. After the previous contributions he made to <a href="https://carton.dev"><code>carton</code></a> it made perfect sense to expand our team. As always, we invite everyone to contribute to any of our repositories, and it doesn't require much prior experience with SwiftWasm if any at all. Bug fixes, feature additions, improved documentation and related changes are very much appreciated and allow our ecosystem to grow even more!</p><h2>SwiftWasm documentation</h2><p>Our documentation was restructured and updated, and is now hosted on the <a href="https://book.swiftwasm.org"><code>book.swiftwasm.org</code></a> domain. Please file all feedback in the <a href="https://github.com/swiftwasm/swiftwasm-book"><code>swiftwasm-book</code></a> repository on GitHub, which hosts its source code.</p><h2>JavaScriptKit</h2><p><a href="https://github.com/swiftwasm/JavaScriptKit">JavaScriptKit</a> had a few important updates in October so far. Most importantly, now that PR <a href="https://github.com/swiftwasm/JavaScriptKit/pull/91">#91</a> by <a href="https://github.com/kateinoigakukun">@kateinoigakukun</a> was merged, JavaScriptKit no longer uses unsafe flags in its <code>Package.swift</code>. The use of unsafe flags was a big problem for us, as it breaks dependency resolution due to strict checks that SwiftPM applies. If any package in your dependency tree contains unsafe flags, you can no longer depend on its semantic version, or a semantic version of any other package that depends on it.</p><p>So far we were able to work around that with a hardcoded check for JavaScriptKit in our fork of SwiftPM. This was obviously a very ugly hack, but the biggest downside of that approach was that you couldn't depend on any package that had a semantic version dependency on JavaScriptKit in upstream Swift toolchains. That meant that libraries like <a href="https://tokamak.dev">Tokamak</a> could not be built for macOS or Linux. And while the WebAssembly DOM renderer in Tokamak is the most useful module right now, this prevented static HTML rendering from working on macOS and Linux.</p><p>Another issue we had with JavaScriptKit is <a href="https://github.com/swiftwasm/JavaScriptKit/issues/87">the naming of <code>JSValueConstructible</code> and <code>JSValueConvertible</code></a> protocols. These protocols are used for conversions between <code>JSValue</code> references and arbitrary Swift values. In practice it wasn't always clear which of these protocols was responsible for a specific conversion. After some deliberation, these were renamed to <code>ConstructibleFromJSValue</code> and <code>ConvertibleToJSValue</code> respectively in <a href="https://github.com/swiftwasm/JavaScriptKit/pull/88">#88</a>.</p><p><a href="https://github.com/swiftwasm/JavaScriptKit/pull/98">A proposal PR</a> was submitted by <a href="https://github.com/kateinoigakukun">@kateinoigakukun</a> to enable unsafe force unwrapping of dynamic member properties in JavaScript by default. That is, we would allow this</p><pre><code><span class="splash-keyword">let</span> document = <span class="splash-type">JSObject</span>.<span class="splash-property">global</span>.<span class="splash-property">document</span>
<span class="splash-keyword">let</span> foundDivs = document.<span class="splash-call">getElementsByTagName</span>(<span class="splash-string">"div"</span>)
</code></pre><p>in addition to the currently available explicit style with force unwrapping:</p><pre><code><span class="splash-keyword">let</span> document = <span class="splash-type">JSObject</span>.<span class="splash-property">global</span>.<span class="splash-property">document</span>.<span class="splash-property">object</span>!
<span class="splash-keyword">let</span> foundDivs = document.<span class="splash-property">getElementsByTagName</span>!(<span class="splash-string">"div"</span>).<span class="splash-property">object</span>!
</code></pre><p>The key thing to note is that the first option is still dynamically typed and these options are equivalent in their behavior. If you address a missing property on your JavaScript object with this API, your SwiftWasm app will crash. One possible reasoning for this change is that this would follow the approach of <a href="https://github.com/tensorflow/swift#why-swift-for-tensorflow">PythonKit and Swift for TensorFlow</a>, and improve readability and ease of use for newcomers. We encourage you to voice your opinion in PR comments to give us more feedback on this proposal.</p><p><a href="https://github.com/swiftwasm/JavaScriptKit/issues/97">An issue was raised</a> by <a href="https://github.com/yonihemi">@yonihemi</a> this week on our JavaScriptKit repository about <code>i64</code> Wasm function return type support in Safari. The reason for it is that <a href="https://webassembly.org/roadmap/">Safari is the only major browser</a> that <a href="https://bugs.webkit.org/show_bug.cgi?id=213528">doesn't support</a> <a href="https://github.com/WebAssembly/JS-BigInt-integration">Wasm <code>i64</code> to <code>BigInt</code> conversion</a>. Unfortunately, there are many APIs that require this conversion to work, and it's unclear yet if this can be polyfilled on the JavaScript side at all. Currently it looks like we need to apply some transformations to binaries produced by SwiftWasm to resolve this issue, but it remains to be seen how well that would work in practice.</p><h2>Tokamak</h2><p>Tokamak didn't see major updates recently, but we've received some important bug reports during the last few weeks. Firstly, there's <a href="https://github.com/TokamakUI/Tokamak/issues/285">an edge case with <code>Picker</code> views</a> that use <code>\.self</code> as an identifier keypath. Secondly, <a href="https://github.com/TokamakUI/Tokamak/issues/287"><code>Toggle</code> binding is not reset</a> after its value changes outside of the view. Many thanks to <a href="https://github.com/rbartolome">@rbartolome</a> for the extensive testing he's given and for reporting these issues!</p><h2>Developer tools</h2><p>In the first half of October <a href="https://github.com/yonihemi">@yonihemi</a> submitted two important quality-of-life improvements to <code>carton</code>:</p><ul><li>Allow changing dev server's port (<a href="https://github.com/swiftwasm/carton/pull/116">#116</a>).</li><li>Automatically open a browser window when dev server starts (<a href="https://github.com/swiftwasm/carton/pull/117">#117</a>).</li></ul><p>There's also an open "Pretty print diagnostics" PR <a href="https://github.com/swiftwasm/carton/pull/122">#112</a> submitted by <a href="https://github.com/carson-katri">@carson-katri</a>. It does some magic with diagnostic messages emitted by the Swift compiler, highlights relevant lines of code and formats all of it nicely. You can check out a preview on this screenshot:</p><img src="https://blog.swiftwasm.org/images/update-02-carton.png" alt="Pretty-print compiler diagnostics in &#96;carton&#96;" width="100%"/><h2>Upstream PRs</h2><p>Not much upstreaming work happened in October yet, but there was some progress in <a href="https://github.com/apple/sourcekit-lsp/pull/330">adding cross-compilation support to SourceKit-LSP</a>. We are also preparing a 5.3 SwiftWasm snapshot with this patch, which will enable this new <code>--destination</code> option on SourceKit-LSP. When that works, we want <code>carton</code> to infer a value for this option and launch it automatically for you when needed. This is all to make auto-complete work correctly for your SwiftWasm apps and libraries in VSCode or any other LSP-supporting editor or LSP.</p><h2>Toolchain/SDK work</h2><p>Most of the work in preparation for the 5.3.0 release of SwiftWasm has been done. Now that it's possible to build JavaScriptKit without unsafe flags, and with IndexStoreDB and SourceKit-LSP shipping with the latest 5.3.0 snapshots, only the last round of testing is needed before tagging a release candidate. The rest of our work on the SwiftWasm toolchain and SDK was mostly related to fixing a build breakage caused by updates to GitHub Actions runner images and resolving conflicts with upstream code.</p><h2>Contributions</h2><p>A lot of the progress wouldn't be possible without payments from our GitHub Sponsors. Their contribution is deeply appreciated and allows us to spend more time on SwiftWasm projects. You can see the list of sponsors and make your contribution on the sponsorship pages of <a href="https://github.com/sponsors/carson-katri">Carson Katri</a>, <a href="https://github.com/sponsors/kateinoigakukun">Yuta Saito</a> and <a href="https://github.com/sponsors/MaxDesiatov">Max Desiatov</a>.</p><p>Thanks for reading! ðŸ‘‹</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.swiftwasm.org/posts/september-2020</guid><title>September 2020 Update</title><description>An update on what happened in the SwiftWasm ecosystem during September 2020.</description><link>https://blog.swiftwasm.org/posts/september-2020</link><pubDate>Wed, 30 Sep 2020 14:34:00 +0000</pubDate><content:encoded><![CDATA[<h1>September 2020 Update</h1><p>Welcome to the SwiftWasm blog! The amount of work happening in <a href="https://github.com/swiftwasm">the SwiftWasm ecosystem</a> is growing, so we decided to start publishing blog updates to give you an overview of what happened recently. This update for September is big enough to be split into different sections for each area of our work, so let's get started. ðŸ™‚</p><h2>Libraries</h2><p><a href="https://github.com/swiftwasm/JavaScriptKit/releases/tag/0.7.0">JavaScriptKit 0.7</a> has been released. It adds multiple new types bridged from JavaScript, namely <code>JSError</code>, <code>JSDate</code>, <code>JSTimer</code> (which corresponds to <code>setTimeout</code>/<code>setInterval</code> calls and manages closure lifetime for you), <code>JSString</code> and <code>JSPromise</code>. We now also have <a href="https://swiftwasm.github.io/JavaScriptKit/">documentation published automatically</a> for the <code>main</code> branch.</p><p>New features of JavaScriptKit allowed us to start working on closer integration with <a href="https://github.com/OpenCombine/OpenCombine">OpenCombine</a>. The current progress is available in the new <a href="https://github.com/swiftwasm/OpenCombineJS">OpenCombineJS</a> repository, and we plan to tag a release for it soon. At the moment it has a <code>JSScheduler</code> class wrapping <code>JSTimer</code> that implements <a href="https://developer.apple.com/documentation/combine/scheduler">the <code>Scheduler</code> protocol</a>, enabling you to use <code>debounce</code> and other time-based operators. Additionally, OpenCombineJS now provides a helper <code>publisher</code> property on <code>JSPromise</code>, which allows you to integrate any promise-based API with an OpenCombine pipeline.</p><p>We also saw a lot of great progress with <a href="https://github.com/swiftwasm/DOMKit">DOMKit</a> in September thanks to the outstanding work by <a href="https://jedfox.com/">Jed Fox</a> and <a href="https://github.com/Unkaputtbar">@Unkaputtbar</a>, which was unblocked by the recent additions to JavaScriptKit. With DOMKit we're going to get type-safe access to the most common browser DOM APIs. It will be expanded in the future to support even more features that currently are only available via JavaScriptKit through force unwrapping and dynamic casting.</p><p>That is, compare the current API you get with JavaScriptKit:</p><pre><code><span class="splash-keyword">import</span> JavaScriptKit

<span class="splash-keyword">let</span> document = <span class="splash-type">JSObject</span>.<span class="splash-property">global</span>.<span class="splash-property">document</span>.<span class="splash-property">object</span>!

<span class="splash-keyword">let</span> divElement = document.<span class="splash-property">createElement</span>!(<span class="splash-string">"div"</span>).<span class="splash-property">object</span>!
divElement.<span class="splash-property">innerText</span> = <span class="splash-string">"Hello, world"</span>
<span class="splash-keyword">let</span> body = document.<span class="splash-property">body</span>.<span class="splash-property">object</span>!
<span class="splash-keyword">_</span> = body.<span class="splash-property">appendChild</span>!(divElement)
</code></pre><p>to an equivalent snippet that could look like this with DOMKit:</p><pre><code><span class="splash-keyword">import</span> DOMKit

<span class="splash-keyword">let</span> document = global.<span class="splash-property">document</span>

<span class="splash-keyword">let</span> divElement = document.<span class="splash-call">createElement</span>(<span class="splash-string">"div"</span>)
divElement.<span class="splash-property">innerText</span> = <span class="splash-string">"Hello, world"</span>
document.<span class="splash-property">body</span>.<span class="splash-call">appendChild</span>(divElement)
</code></pre><p>Lastly on the libraries front, <a href="https://github.com/TokamakUI/Tokamak/releases">Tokamak 0.4</a> is now available, enabling compatibility with the new version of JavaScriptKit, and utilizing the aforementioned <code>JSScheduler</code> implementation.</p><h2>Developer tools</h2><p>Following the new 0.7 release of JavaScriptKit, <a href="https://github.com/swiftwasm/carton/releases/tag/0.6.0"><code>carton</code> 0.6</a> has been tagged, shipping with the appropriate JavaScriptKit runtime compatible with the new release. It also includes support for the new <code>carton bundle</code> command that produces a directory with optimized build output ready for deployment on a CDN or any other server. Notably, both <code>carton bundle</code> and <code>carton dev</code> support <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0271-package-manager-resources.md">SwiftPM package resources</a>, allowing you to include additional static content in your SwiftWasm apps. These could be styles, scripts, images, fonts, or whatever other data you'd like to ship with your app.</p><p>This version of <code>carton</code> also ships with the latest version of <a href="https://github.com/wasmerio/wasmer-js/">wasmer.js</a>, which fixes compatibility with recently released Safari 14.</p><h2>Toolchain/SDK work</h2><p>The upstream Swift toolchain has switched to <a href="http://llvm.org">LLVM</a> 11 in the <code>main</code> branch, which caused a substantial amount of conflicts in our forked repositories. Resolving the conflicts and making sure everything builds properly consumed a lot of our time in September. You could've noticed that the previously steady stream of nighly development snapshots stalled for most of September, but it resumed starting with <code>wasm-DEVELOPMENT-SNAPSHOT-2020-09-20-a</code>.</p><p>As for the 5.3 branch, with the upstream Swift 5.3.0 release now generally available, we're now preparing a stable SwiftWasm 5.3.0 release. It is based off upstream 5.3.0 with our patches applied to the toolchain and the SDK. <a href="https://github.com/swiftwasm/swift/issues/1759">We've created a checklist</a> that allows us to track the progress of this effort.</p><p>One of the issues we wanted to resolve before tagging SwiftWasm 5.3.0 is the inconsistency between WASI and Glibc APIs. While parts of those look and works the same, the rest are significantly different. Because of this, in subsequent snapshots our users need to use <code>import WASILibc</code> instead of <code>import Glibc</code> if they need to access to libc on the WASI platform. This has already landed in the <code>swiftwasm-release/5.3</code> branch with <a href="https://github.com/swiftwasm/swift/pull/1773">swiftwasm/swift#1773</a> and is available in <code>wasm-5.3-SNAPSHOT-2020-09-23-a</code> or later. It was also implemented in the main <code>swiftwasm</code> branch in <a href="https://github.com/swiftwasm/swift/pull/1832">swiftwasm/swift#1832</a>, all thanks to the amazing work by <a href="https://github.com/sponsors/kateinoigakukun">Yuta Saito</a>.</p><h2>Upstream PRs</h2><p>The divergence between the SwiftWasm toolchain/SDKs and their upstream version is still significant and causes regular conflicts that we have to resolve manually. We're working on making our changes available upstream, but this takes a lot of time, as upstream toolchain and SDK PRs need high level of polish to be accepted. Here's a list of PRs that had some progress in September:</p><h3>Foundation</h3><ul><li>Add locking primitives for <code>TARGET_OS_WASI</code> in <code>CFLocking.h</code> <a href="https://github.com/apple/swift-corelibs-foundation/pull/2867">apple/swift-corelibs-foundation#2867</a>. <strong>Status: merged.</strong></li><li>Add support for WASI in <code>CFInternal.h</code> <a href="https://github.com/apple/swift-corelibs-foundation/pull/2872">apple/swift-corelibs-foundation#2872</a>. <strong>Status: merged.</strong></li><li>Add WASI support in <code>CoreFoundation_Prefix.h</code> <a href="https://github.com/apple/swift-corelibs-foundation/pull/2873">apple/swift-corelibs-foundation#2873</a>. <strong>Status: merged.</strong></li><li>Add support for WASI in <code>CFDate.c</code> <a href="https://github.com/apple/swift-corelibs-foundation/pull/2880">apple/swift-corelibs-foundation#2880</a>. <strong>Status: in review.</strong></li></ul><h3>SwiftPM</h3><ul><li>Propagate PATH to UserToolchain to fix sysroot search <a href="https://github.com/apple/swift-package-manager/pull/2936">apple/swift-package-manager#2936</a>. <strong>Status: merged.</strong></li></ul><h2>Contributions</h2><p>We hope you can contribute to the SwiftWasm ecosystem, either to any of the projects listed above, or with your own libraries and apps that you built. We'd be very happy to feature your open-source work in our next update! Our <a href="https://github.com/swiftwasm/swiftwasm.org"><code>swiftwasm.org</code> website</a> and <a href="https://github.com/swiftwasm/blog.swiftwasm.org">this blog</a> are open-source, so please feel free to open an issue or a pull request with a link to your work related to SwiftWasm.</p><p>A lot of the progress wouldn't be possible without payments from our GitHub Sponsors. Their contribution is deeply appreciated and allows us to spend more time on SwiftWasm projects. You can see the list of sponsors and make your contribution on the sponsorship pages of <a href="https://github.com/sponsors/kateinoigakukun">Yuta Saito</a> and <a href="https://github.com/sponsors/MaxDesiatov">Max Desiatov</a>.</p><p>Thanks for reading! ðŸ‘‹</p>]]></content:encoded></item></channel></rss>