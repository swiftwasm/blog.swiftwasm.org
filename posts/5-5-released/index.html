<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="SwiftWasm Blog"/><link rel="canonical" href="https://blog.swiftwasm.org/posts/5-5-released"/><meta name="twitter:url" content="https://blog.swiftwasm.org/posts/5-5-released"/><meta name="og:url" content="https://blog.swiftwasm.org/posts/5-5-released"/><title>SwiftWasm 5.5.0 is now available | SwiftWasm Blog</title><meta name="twitter:title" content="SwiftWasm 5.5.0 is now available | SwiftWasm Blog"/><meta name="og:title" content="SwiftWasm 5.5.0 is now available | SwiftWasm Blog"/><meta name="description" content="SwiftWasm 5.5.0 with support for async/await and Apple Silicon has been released."/><meta name="twitter:description" content="SwiftWasm 5.5.0 with support for async/await and Apple Silicon has been released."/><meta name="og:description" content="SwiftWasm 5.5.0 with support for async/await and Apple Silicon has been released."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><link rel="stylesheet" href="/splash.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link href="https://fonts.googleapis.com/css2?family=Lora:wght@600&display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css2?family=Open+Sans&display=swap" rel="stylesheet"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to SwiftWasm Blog"/></head><body class="item-page"><header><div class="wrapper"><a class="site-name" href="/">SwiftWasm Blog</a></div></header><div class="wrapper"><article><p><small>Published on <time datetime="2021-11-29T10:10:00Z">November 29, 2021.</time></small></p><div class="content"><h1>SwiftWasm 5.5.0 is now available</h1><p>We're happy to announce the new release of SwiftWasm tracking upstream Swift 5.5! Notably, in this release we've added support for <code>async</code>/<code>await</code>. This new feature of Swift can be integrated with JavaScript promises when you're using a new version of <a href="https://github.com/swiftwasm/JavaScriptKit">JavaScriptKit</a> that was recently tagged. See the corresponding section below for more details.</p><p>Since multi-threading in WebAssembly is still not supported across all browsers (<a href="https://webassembly.org/roadmap/">Safari is the only one lagging behind</a>), this release of SwiftWasm doesn't include the Dispatch library and ships with a single-threaded cooperative executor. This means that <code>actor</code> declarations in your code will behave as plain reference types and will all be scheduled on the main thread. If you need true parallel computation, you’ll have to write custom code against the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Web Workers API</a> (either via JavaScriptKit or delegating to raw JavaScript) to synchronize multiple SwiftWasm runtimes.</p><p>Additionally, 5.5.0 is the first release of SwiftWasm that supports Apple Silicon natively. The latest version of <a href="https://github.com/swiftwasm/carton"><code>carton</code></a> (0.12.0) will download the <code>arm64</code> distribution on Apple Silicon devices.</p><h2>New JavaScriptKit runtime</h2><p>The 0.11 release of <a href="https://github.com/swiftwasm/JavaScriptKit">JavaScriptKit</a> adds support for <code>async</code>/<code>await</code> and <code>JSPromise</code> integration. Now instances of this class have an effectful <code>async</code> property <code>value</code>. Here's example code that shows you how can <code>fetch</code> browser API be used without callbacks:</p><pre><code><span class="splash-keyword">import</span> JavaScriptKit
<span class="splash-keyword">import</span> JavaScriptEventLoop

<span class="splash-comment">// This line is required for `JSPromise.value` to work.</span>
<span class="splash-type">JavaScriptEventLoop</span>.<span class="splash-call">installGlobalExecutor</span>()

<span class="splash-keyword">private let</span> jsFetch = <span class="splash-type">JSObject</span>.<span class="splash-property">global</span>.<span class="splash-property">fetch</span>.<span class="splash-property">function</span>!
<span class="splash-keyword">func</span> fetch(<span class="splash-keyword">_</span> url: <span class="splash-type">String</span>) -&gt; <span class="splash-type">JSPromise</span> {
    <span class="splash-type">JSPromise</span>(<span class="splash-call">jsFetch</span>(url).<span class="splash-property">object</span>!)!
}

<span class="splash-keyword">struct</span> Response: <span class="splash-type">Decodable</span> {
    <span class="splash-keyword">let</span> uuid: <span class="splash-type">String</span>
}

<span class="splash-keyword">let</span> alert = <span class="splash-type">JSObject</span>.<span class="splash-property">global</span>.<span class="splash-property">alert</span>.<span class="splash-property">function</span>!
<span class="splash-keyword">let</span> document = <span class="splash-type">JSObject</span>.<span class="splash-property">global</span>.<span class="splash-property">document</span>

<span class="splash-keyword">var</span> asyncButtonElement = document.<span class="splash-call">createElement</span>(<span class="splash-string">"button"</span>)
asyncButtonElement.<span class="splash-property">innerText</span> = <span class="splash-string">"Fetch UUID demo"</span>
asyncButtonElement.<span class="splash-property">onclick</span> = .<span class="splash-call">object</span>(<span class="splash-type">JSClosure</span> { <span class="splash-keyword">_ in</span>
    <span class="splash-type">Task</span> {
        <span class="splash-keyword">do</span> {
            <span class="splash-keyword">let</span> response = <span class="splash-keyword">try await</span> <span class="splash-call">fetch</span>(<span class="splash-string">"https://httpbin.org/uuid"</span>).<span class="splash-property">value</span>
            <span class="splash-keyword">let</span> json = <span class="splash-keyword">try await</span> <span class="splash-type">JSPromise</span>(response.<span class="splash-call">json</span>().<span class="splash-property">object</span>!)!.value
            <span class="splash-keyword">let</span> parsedResponse = <span class="splash-keyword">try</span> <span class="splash-type">JSValueDecoder</span>().<span class="splash-call">decode</span>(<span class="splash-type">Response</span>.<span class="splash-keyword">self</span>, from: json)
            <span class="splash-call">alert</span>(parsedResponse.<span class="splash-property">uuid</span>)
        } <span class="splash-keyword">catch</span> {
            <span class="splash-call">print</span>(error)
        }
    }

    <span class="splash-keyword">return</span> .<span class="splash-dotAccess">undefined</span>
})

<span class="splash-keyword">_</span> = document.<span class="splash-property">body</span>.<span class="splash-call">appendChild</span>(asyncButtonElement)
</code></pre><p>Also, in this version of JavaScriptKit we're simplifying the <code>JSClosure</code> API. You no longer need to release instances of this class manually, as they will be automatically garbage-collected by the browser after neither your Swift code nor the JavaScript runtime hold any references to them. This is achieved with the new</p><p><code>FinalizationRegistry</code> Web API, for which we had to significantly increase minimum browser versions required for JavaScriptKit to work. See <a href="https://github.com/swiftwasm/JavaScriptKit#readme"><code>README.md</code></a> in the project repository for more details.</p><p>We have to mention that there's still a possibility of reference cycles with this new API. <code>FinalizationRegistry</code> doesn't implement full GC for JS closures, but it only solves dangling closure issue. For example, in this code</p><pre><code><span class="splash-keyword">var</span> button = document.<span class="splash-call">createElement</span>(<span class="splash-string">"button"</span>)
button.<span class="splash-property">onclick</span> = .<span class="splash-call">object</span>(<span class="splash-type">JSClosure</span> { [button] <span class="splash-keyword">in</span>
  <span class="splash-comment">// this capture makes a reference cycle</span>
  <span class="splash-call">print</span>(button)
})
</code></pre><p>a reference cycle is created</p><pre><code>┌─&gt; <span class="splash-type">JSObject</span> (button <span class="splash-keyword">in</span> <span class="splash-type">Swift</span>) -&gt; <span class="splash-type">HTMLElement</span> (button <span class="splash-keyword">in</span> <span class="splash-type">JS</span>) ────┐
└── <span class="splash-type">JSClosure</span> (onclick <span class="splash-keyword">in</span> <span class="splash-type">Swift</span>) &lt;─&gt; <span class="splash-type">Closure</span> (onclick <span class="splash-keyword">in</span> <span class="splash-type">JS</span>) &lt;───┘
</code></pre><p>In this case, when <code>button</code> element is removed from the main DOM tree, it cannot be deallocated. The <code>onclick</code> closure is still referenced by the button itself. These reference cycles can be resolved with the usual <code>weak</code> captures you're probably used to writing in your AppKit and UIKit code.</p><h2>Tokamak</h2><p>Based on the improvements to JavaScriptKit and major work by our contributors, we're also tagging a new 0.9.0 release of <a href="https://github.com/TokamakUI/Tokamak">Tokamak</a>, a SwiftUI-compatible framework for building browser apps with WebAssembly. We've added:</p><ul><li><code>Canvas</code> and <code>TimelineView</code> types;</li><li><code>onHover</code> modifier;</li><li><code>task</code> modifier for running <code>async</code> functions;</li><li>Sanitizers for the <code>Text</code> view.</li></ul><p>Tokamak v0.9.0 now requires Swift 5.4 or newer. Swift 5.5 (with SwiftWasm 5.5 when targeting the browser environment) is recommended.</p><h2>Acknowledgements</h2><p>We'd like to thank <a href="https://github.com/sponsors/swiftwasm">our sponsors</a> for their support, which allowed us to continue working on SwiftWasm and related project.</p><p>Many thanks to <a href="https://www.macstadium.com">MacStadium</a> for giving us access to Apple Silicon hardware. Without their help it would be close to impossible to set up CI for enabling full M1 support in our toolchain.</p><p>Additionally, we'd like to thank everyone who contributed their work and helped us make this release happen. These new releases wouldn't be possible without the hard work of (in alphabetical order):</p><ul><li><a href="https://github.com/agg23">@agg23</a></li><li><a href="https://github.com/carson-katri">@carson-katri</a></li><li><a href="https://github.com/ezraberch">@ezraberch</a></li><li><a href="https://github.com/Feuermurmel">@Feuermurmel</a></li><li><a href="https://github.com/kateinoigakukun">@kateinoigakukun</a></li><li><a href="https://github.com/MaxDesiatov">@MaxDesiatov</a></li><li><a href="https://github.com/mbrandonw">@mbrandonw</a></li><li><a href="https://github.com/PatrickPijnappel">@PatrickPijnappel</a></li><li><a href="https://github.com/yonihemi/">@yonihemi</a></li><li>all of our users, and everyone working on the Swift project and libraries we depend on!</li></ul></div></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>